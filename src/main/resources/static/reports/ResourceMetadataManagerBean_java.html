<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for ResourceMetadataManagerBean.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />
    <link rel="shortcut icon" href="resources/img/rhamt-icon-128.png" type="image/x-icon"/>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-default navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
              <strong class="wu-navbar-header">Red Hat Application Migration Toolkit</strong>
            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4062208">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.1.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-compressed"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ejbreport_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon ejb-nav-logo"></i>
                      EJBs
                    </a>
                </li>


                <li class="">
                    <a href="jpa_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon jpa-nav-logo"></i>
                      JPA
                    </a>
                </li>


                <li class="">
                    <a href="server_resources_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon server-resource-nav-logo"></i>
                      Server Resources
                    </a>
                </li>


                <li class="">
                    <a href="hardcoded_ipsRHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-map-marker"></i>
                      Hard-coded IP Addresses
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-info-sign"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.jboss.org/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report</div>

                        <div class="path project-specific" data-project-id="4062208">
                            rhq-enterprise-server-ear-1.3.0.EmbJopr.1.3.0-4.ear/rhq-enterprise-server-ejb3.jar/org/rhq/enterprise/server/resource/metadata/ResourceMetadataManagerBean.java
                        </div>
                </h1>
                <div class="desc">
                    This report displays what Red Hat Application Migration Toolkit found in individual files.
                    Each item is shown below the line it was found on,
                    and next to it, you may find a link to the rule which it was found by.
                </div>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">

                            <h4>Technologies</h4>
                            <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                    <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                            </div>



                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package org.rhq.enterprise.server.resource.metadata;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.NoResultException;
import javax.persistence.NonUniqueResultException;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.sql.DataSource;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.rhq.core.clientapi.agent.metadata.PluginMetadataManager;
import org.rhq.core.clientapi.agent.metadata.SubCategoriesMetadataParser;
import org.rhq.core.clientapi.descriptor.AgentPluginDescriptorUtil;
import org.rhq.core.clientapi.descriptor.plugin.PluginDescriptor;
import org.rhq.core.domain.auth.Subject;
import org.rhq.core.domain.authz.Permission;
import org.rhq.core.domain.configuration.definition.ConfigurationDefinition;
import org.rhq.core.domain.content.PackageType;
import org.rhq.core.domain.event.EventDefinition;
import org.rhq.core.domain.measurement.MeasurementDefinition;
import org.rhq.core.domain.operation.OperationDefinition;
import org.rhq.core.domain.plugin.Plugin;
import org.rhq.core.domain.resource.ProcessScan;
import org.rhq.core.domain.resource.ResourceCategory;
import org.rhq.core.domain.resource.ResourceSubCategory;
import org.rhq.core.domain.resource.ResourceType;
import org.rhq.core.util.jdbc.JDBCUtil;
import org.rhq.enterprise.server.auth.SubjectManagerLocal;
import org.rhq.enterprise.server.authz.RequiredPermission;
import org.rhq.enterprise.server.configuration.metadata.ConfigurationMetadataManagerLocal;
import org.rhq.enterprise.server.event.EventManagerLocal;
import org.rhq.enterprise.server.measurement.MeasurementDefinitionManagerLocal;
import org.rhq.enterprise.server.measurement.MeasurementScheduleManagerLocal;
import org.rhq.enterprise.server.resource.ResourceManagerLocal;
import org.rhq.enterprise.server.resource.metadata.ResourceMetadataManagerLocal;

@Stateless
@Resource(
   name = &quot;RHQ_DS&quot;,
   mappedName = &quot;java:/RHQDS&quot;
)
public class ResourceMetadataManagerBean implements ResourceMetadataManagerLocal {
   private final Log log = LogFactory.getLog(ResourceMetadataManagerBean.class);
   @Resource(
      name = &quot;RHQ_DS&quot;
   )
   private DataSource dataSource;
   @PersistenceContext(
      unitName = &quot;rhqpu&quot;
   )
   private EntityManager entityManager;
   private static final PluginMetadataManager PLUGIN_METADATA_MANAGER = new PluginMetadataManager();
   @EJB
   private MeasurementDefinitionManagerLocal measurementDefinitionManager;
   @EJB
   private MeasurementScheduleManagerLocal scheduleManager;
   @EJB
   private ConfigurationMetadataManagerLocal configurationMetadataManager;
   @EJB
   private SubjectManagerLocal subjectManager;
   @EJB
   private ResourceManagerLocal resourceManager;
   @EJB
   private EventManagerLocal eventManager;

   public Plugin getPlugin(String name) {
      Query query = this.entityManager.createNamedQuery(&quot;Plugin.findByName&quot;);
      query.setParameter(&quot;name&quot;, name);
      Plugin plugin = (Plugin)query.getSingleResult();
      return plugin;
   }

   public List getPlugins() {
      Query q = this.entityManager.createNamedQuery(&quot;Plugin.findAll&quot;);
      return q.getResultList();
   }

   public List getPluginsByResourceTypeAndCategory(String resourceTypeName, ResourceCategory resourceCategory) {
      Query query = this.entityManager.createNamedQuery(&quot;Plugin.findByResourceType&quot;);
      query.setParameter(&quot;resourceTypeName&quot;, resourceTypeName);
      query.setParameter(&quot;resourceCategory&quot;, resourceCategory);
      List results = query.getResultList();
      return results;
   }

   @RequiredPermission(Permission.MANAGE_SETTINGS)
   public void registerPlugin(Subject whoami, Plugin plugin, PluginDescriptor pluginDescriptor, File pluginFile, boolean forceUpdate) throws Exception {
      Plugin existingPlugin = null;
      boolean newOrUpdated = false;

      try {
         existingPlugin = this.getPlugin(plugin.getName());
      } catch (NoResultException var9) {
         newOrUpdated = true;
      }

      if(existingPlugin != null) {
         Plugin rootResourceTypes = AgentPluginDescriptorUtil.determineObsoletePlugin(plugin, existingPlugin);
         if(rootResourceTypes == existingPlugin) {
            newOrUpdated = true;
         }

         plugin.setId(existingPlugin.getId());
      }

      if(newOrUpdated) {
         if(plugin.getDisplayName() == null) {
            plugin.setDisplayName(plugin.getName());
         }

         plugin = this.updatePluginExceptContent(plugin);
         if(pluginFile != null) {
            this.entityManager.flush();
            this.streamPluginFileContentToDatabase(plugin.getId(), pluginFile);
         }

         this.log.debug(&quot;Updated plugin entity [&quot; + plugin + &quot;]&quot;);
      }

      if(newOrUpdated || forceUpdate || !PLUGIN_METADATA_MANAGER.getPluginNames().contains(plugin.getName())) {
         Set rootResourceTypes1 = PLUGIN_METADATA_MANAGER.loadPlugin(pluginDescriptor);
         if(rootResourceTypes1 == null) {
            throw new Exception(&quot;Failed to load plugin [&quot; + plugin.getName() + &quot;].&quot;);
         }

         if(newOrUpdated || forceUpdate) {
            this.updateTypes(plugin.getName(), rootResourceTypes1);
         }
      }

   }

   private Plugin updatePluginExceptContent(Plugin plugin) throws Exception {
      if(plugin.getId() == 0) {
         this.entityManager.persist(plugin);
      } else {
         Query q = this.entityManager.createNamedQuery(&quot;Plugin.updateAllButContent&quot;);
         q.setParameter(&quot;id&quot;, Integer.valueOf(plugin.getId()));
         q.setParameter(&quot;name&quot;, plugin.getName());
         q.setParameter(&quot;path&quot;, plugin.getPath());
         q.setParameter(&quot;displayName&quot;, plugin.getDisplayName());
         q.setParameter(&quot;enabled&quot;, Boolean.valueOf(plugin.isEnabled()));
         q.setParameter(&quot;md5&quot;, plugin.getMD5());
         q.setParameter(&quot;version&quot;, plugin.getVersion());
         q.setParameter(&quot;description&quot;, plugin.getDescription());
         q.setParameter(&quot;help&quot;, plugin.getHelp());
         q.setParameter(&quot;mtime&quot;, Long.valueOf(plugin.getMtime()));
         if(q.executeUpdate() != 1) {
            throw new Exception(&quot;Failed to update a plugin that matches [&quot; + plugin + &quot;]&quot;);
         }
      }

      return plugin;
   }

   private void streamPluginFileContentToDatabase(int id, File file) throws Exception {
      Connection conn = null;
      PreparedStatement ps = null;
      Object rs = null;
      FileInputStream fis = new FileInputStream(file);

      try {
         conn = this.dataSource.getConnection();
         ps = conn.prepareStatement(&quot;UPDATE RHQ_PLUGIN SET CONTENT = ? WHERE ID = ?&quot;);
         ps.setBinaryStream(1, new BufferedInputStream(fis), (int)file.length());
         ps.setInt(2, id);
         int updateResults = ps.executeUpdate();
         if(updateResults != 1) {
            throw new Exception(&quot;Failed to update content for plugin [&quot; + id + &quot;] from [&quot; + file + &quot;]&quot;);
         }
      } finally {
         JDBCUtil.safeClose(conn, ps, (ResultSet)rs);

         try {
            fis.close();
         } catch (Throwable var14) {
            ;
         }

      }

   }

   private void updateTypes(String pluginName, Set rootResourceTypes) throws Exception {
      Iterator i$ = rootResourceTypes.iterator();

      while(i$.hasNext()) {
         ResourceType rootResourceType = (ResourceType)i$.next();
         this.updateType(rootResourceType);
      }

      this.removeObsoleteTypes(pluginName);
   }

   private void removeObsoleteTypes(String pluginName) {
      Query query = this.entityManager.createNamedQuery(&quot;ResourceType.findByPlugin&quot;);
      query.setParameter(&quot;plugin&quot;, pluginName);
      List existingTypes = query.getResultList();
      if(existingTypes != null) {
         Subject overlord = this.subjectManager.getOverlord();
         Iterator i$ = existingTypes.iterator();

         label70:
         while(true) {
            ResourceType remainingType;
            do {
               if(!i$.hasNext()) {
                  i$ = existingTypes.iterator();

                  while(i$.hasNext()) {
                     remainingType = (ResourceType)i$.next();
                     ResourceType updateType1 = PLUGIN_METADATA_MANAGER.getType(remainingType.getName(), remainingType.getPlugin());
                     if(updateType1 != null) {
                        this.removeSubCategories(updateType1, remainingType);
                        this.entityManager.flush();
                     }
                  }
                  break label70;
               }

               remainingType = (ResourceType)i$.next();
            } while(PLUGIN_METADATA_MANAGER.getType(remainingType.getName(), remainingType.getPlugin()) != null);

            if(this.entityManager.contains(remainingType)) {
               this.entityManager.refresh(remainingType);
            }

            this.removeFromParents(remainingType);
            List updateType = remainingType.getResources();
            if(updateType != null) {
               Iterator definitions = updateType.iterator();

               while(definitions.hasNext()) {
                  org.rhq.core.domain.resource.Resource defIter = (org.rhq.core.domain.resource.Resource)definitions.next();
                  List def = this.resourceManager.deleteResource(overlord, defIter.getId());
                  Iterator i$1 = def.iterator();

                  while(i$1.hasNext()) {
                     Integer deletedResourceId = (Integer)i$1.next();
                     this.resourceManager.deleteSingleResourceInNewTransaction(overlord, deletedResourceId.intValue());
                  }

                  definitions.remove();
               }
            }

            this.entityManager.flush();
            Set definitions1 = remainingType.getMetricDefinitions();
            if(definitions1 != null) {
               for(Iterator defIter1 = definitions1.iterator(); defIter1.hasNext(); defIter1.remove()) {
                  MeasurementDefinition def1 = (MeasurementDefinition)defIter1.next();
                  if(this.entityManager.contains(def1)) {
                     this.entityManager.refresh(def1);
                     this.measurementDefinitionManager.removeMeasurementDefinition(def1);
                  }
               }
            }

            this.entityManager.flush();
            this.entityManager.remove(remainingType);
            this.entityManager.flush();
            i$.remove();
         }
      }

   }

   private void removeFromParents(ResourceType typeToBeRemoved) {
      HashSet parents = new HashSet(typeToBeRemoved.getParentResourceTypes());
      Iterator i$ = parents.iterator();

      while(i$.hasNext()) {
         ResourceType parent = (ResourceType)i$.next();
         parent.removeChildResourceType(typeToBeRemoved);
      }

   }

   private void updateType(ResourceType resourceType) {
      try {
         this.entityManager.flush();
         if(this.log.isDebugEnabled()) {
            this.log.debug(&quot;Updating resource type [&quot; + resourceType.getName() + &quot;] from plugin [&quot; + resourceType.getPlugin() + &quot;]...&quot;);
         }

         Query nure = this.entityManager.createNamedQuery(&quot;ResourceType.findByNameAndPlugin&quot;);
         nure.setParameter(&quot;name&quot;, resourceType.getName()).setParameter(&quot;plugin&quot;, resourceType.getPlugin());
         List findTypeByNameAndPlugin = nure.getResultList();
         ResourceType existingType = null;
         if(findTypeByNameAndPlugin.size() == 1) {
            existingType = (ResourceType)findTypeByNameAndPlugin.get(0);
         }

         this.updateParentResourceTypes(resourceType, existingType);
         if(findTypeByNameAndPlugin.size() == 0) {
            throw new NoResultException();
         }

         Iterator oldSubCat;
         ResourceType newSubCat;
         if(findTypeByNameAndPlugin.size() &gt; 1) {
            if(this.log.isDebugEnabled()) {
               oldSubCat = findTypeByNameAndPlugin.iterator();

               while(oldSubCat.hasNext()) {
                  newSubCat = (ResourceType)oldSubCat.next();
                  this.log.debug(&quot;updateType: found: &quot; + newSubCat);
               }
            }

            if(findTypeByNameAndPlugin.size() != 2) {
               throw new IllegalArgumentException(&quot;We only expected two results here, but got &quot; + findTypeByNameAndPlugin.size());
            }

            oldSubCat = findTypeByNameAndPlugin.iterator();
            newSubCat = (ResourceType)oldSubCat.next();
            ResourceType existingSubCat = (ResourceType)oldSubCat.next();
            if(newSubCat.equals(resourceType)) {
               existingType = existingSubCat;
            } else {
               if(!existingSubCat.equals(resourceType)) {
                  throw new IllegalArgumentException(&quot;Existing ResourceType not found for &quot; + resourceType);
               }

               existingType = newSubCat;
            }
         }

         this.updateChildSubCategories(resourceType, existingType);
         oldSubCat = resourceType.getChildResourceTypes().iterator();

         while(oldSubCat.hasNext()) {
            newSubCat = (ResourceType)oldSubCat.next();
            this.updateType(newSubCat);
         }

         this.entityManager.flush();
         this.updatePluginConfiguration(resourceType, existingType);
         this.entityManager.flush();
         this.updateResourceConfiguration(resourceType, existingType);
         this.updateMeasurementDefinitions(resourceType, existingType);
         this.updateContentDefinitions(resourceType, existingType);
         this.updateOperationDefinitions(resourceType, existingType);
         this.updateProcessScans(resourceType, existingType);
         this.updateEventDefinitions(resourceType, existingType);
         existingType.setDescription(resourceType.getDescription());
         existingType.setCreateDeletePolicy(resourceType.getCreateDeletePolicy());
         existingType.setCreationDataType(resourceType.getCreationDataType());
         existingType.setSingleton(resourceType.isSingleton());
         existingType.setSupportsManualAdd(resourceType.isSupportsManualAdd());
         ResourceSubCategory oldSubCat1 = existingType.getSubCategory();
         ResourceSubCategory newSubCat1 = resourceType.getSubCategory();
         if(oldSubCat1 == null || !oldSubCat1.equals(newSubCat1)) {
            if(newSubCat1 == null) {
               if(oldSubCat1 != null) {
                  this.log.debug(&quot;Metadata update: Subcategory of ResourceType [&quot; + resourceType.getName() + &quot;] changed from &quot; + oldSubCat1 + &quot; to &quot; + newSubCat1);
                  existingType.setSubCategory((ResourceSubCategory)null);
               }
            } else {
               ResourceSubCategory existingSubCat1 = SubCategoriesMetadataParser.findSubCategoryOnResourceTypeAncestor(existingType, newSubCat1.getName());
               if(existingSubCat1 == null) {
                  throw new IllegalStateException(&quot;Resource type [&quot; + resourceType.getName() + &quot;] in plugin [&quot; + resourceType.getPlugin() + &quot;] has a subcategory (&quot; + newSubCat1.getName() + &quot;) which was not defined as a child subcategory of one of its ancestor resource types.&quot;);
               }

               this.log.debug(&quot;Metadata update: Subcategory of ResourceType [&quot; + resourceType.getName() + &quot;] changed from &quot; + oldSubCat1 + &quot; to &quot; + existingSubCat1);
               existingType.setSubCategory(existingSubCat1);
            }
         }

         existingType = (ResourceType)this.entityManager.merge(existingType);
         this.entityManager.flush();
      } catch (NoResultException var8) {
         this.checkForValidSubcategories(resourceType.getChildSubCategories());
         this.linkSubCategoryToParents(resourceType);
         if(this.log.isDebugEnabled()) {
            this.log.debug(&quot;Persisting new ResourceType: &quot; + resourceType);
         }

         this.entityManager.persist(resourceType);
      } catch (NonUniqueResultException var9) {
         this.log.debug(&quot;Found more than one existing ResourceType for &quot; + resourceType);
         throw new IllegalStateException(var9);
      }

   }

   private void linkSubCategoryToParents(ResourceType resourceType) {
      if(resourceType.getSubCategory() != null) {
         ResourceSubCategory mySubCategory = resourceType.getSubCategory();
         ResourceSubCategory existingCat = SubCategoriesMetadataParser.findSubCategoryOnResourceTypeAncestor(resourceType, mySubCategory.getName());
         if(existingCat != null) {
            resourceType.setSubCategory(existingCat);
         } else {
            throw new IllegalStateException(&quot;Subcategory &quot; + mySubCategory.getName() + &quot; defined on resource type &quot; + resourceType.getName() + &quot; in plugin &quot; + resourceType.getPlugin() + &quot; is not defined in a parent type&quot;);
         }
      }
   }

   private void updateParentResourceTypes(ResourceType resourceType, ResourceType existingType) {
      HashSet types = new HashSet(resourceType.getParentResourceTypes());
      resourceType.setParentResourceTypes(new HashSet());
      Iterator i$ = types.iterator();

      while(i$.hasNext()) {
         ResourceType resourceTypeParent = (ResourceType)i$.next();

         try {
            ResourceType nre = (ResourceType)this.entityManager.createNamedQuery(&quot;ResourceType.findByNameAndPlugin&quot;).setParameter(&quot;name&quot;, resourceTypeParent.getName()).setParameter(&quot;plugin&quot;, resourceTypeParent.getPlugin()).getSingleResult();
            nre.addChildResourceType(existingType != null?existingType:resourceType);
         } catch (NoResultException var7) {
            throw new RuntimeException(&quot;Couldn\'t persist type [&quot; + resourceType + &quot;] because parent wasn\'t already persisted [&quot; + resourceTypeParent + &quot;]&quot;);
         }
      }

   }

   private void checkForValidSubcategories(List subCategories) {
      HashSet subCatNames = new HashSet();
      Iterator i$ = subCategories.iterator();

      while(i$.hasNext()) {
         ResourceSubCategory subCategory = (ResourceSubCategory)i$.next();
         List allSubcategories = this.getAllSubcategories(subCategory);
         Iterator i$1 = allSubcategories.iterator();

         while(i$1.hasNext()) {
            ResourceSubCategory subCategory2 = (ResourceSubCategory)i$1.next();
            if(subCatNames.contains(subCategory2.getName())) {
               throw new RuntimeException(&quot;Subcategory [&quot; + subCategory.getName() + &quot;] is duplicated&quot;);
            }

            subCatNames.add(subCategory2.getName());
         }
      }

   }

   private List getAllSubcategories(ResourceSubCategory cat) {
      ArrayList result = new ArrayList();
      if(cat.getChildSubCategories() != null) {
         Iterator i$ = cat.getChildSubCategories().iterator();

         while(i$.hasNext()) {
            ResourceSubCategory cat2 = (ResourceSubCategory)i$.next();
            result.addAll(this.getAllSubcategories(cat2));
         }
      }

      result.add(cat);
      return result;
   }

   private void updateEventDefinitions(ResourceType newType, ResourceType existingType) {
      Set newEventDefs = newType.getEventDefinitions();
      Iterator existingEventDefs = newEventDefs.iterator();

      while(existingEventDefs.hasNext()) {
         EventDefinition toDelete = (EventDefinition)existingEventDefs.next();
         toDelete.setResourceTypeId(existingType.getId());
      }

      Set existingEventDefs1 = existingType.getEventDefinitions();
      Iterator toDelete1 = existingEventDefs1.iterator();

      while(toDelete1.hasNext()) {
         EventDefinition newOnes = (EventDefinition)toDelete1.next();
         this.entityManager.refresh(newOnes);
      }

      Set toDelete2 = this.missingInFirstSet(newEventDefs, existingEventDefs1);
      Set newOnes1 = this.missingInFirstSet(existingEventDefs1, newEventDefs);
      Set toUpdate = this.intersection(newEventDefs, existingEventDefs1);
      Iterator i$ = existingEventDefs1.iterator();

      EventDefinition eDef;
      while(i$.hasNext()) {
         eDef = (EventDefinition)i$.next();
         Iterator e2 = toUpdate.iterator();

         while(e2.hasNext()) {
            EventDefinition nDef = (EventDefinition)e2.next();
            if(eDef.equals(nDef)) {
               eDef.setDescription(nDef.getDescription());
               eDef.setDisplayName(nDef.getDisplayName());
            }
         }
      }

      i$ = newOnes1.iterator();

      while(i$.hasNext()) {
         eDef = (EventDefinition)i$.next();
         EventDefinition e21 = new EventDefinition(existingType, eDef.getName());
         e21.setDescription(eDef.getDescription());
         e21.setDisplayName(eDef.getDisplayName());
         this.entityManager.persist(e21);
         existingType.addEventDefinition(e21);
      }

      existingEventDefs1.removeAll(toDelete2);
      this.entityManager.flush();
      i$ = toDelete2.iterator();

      while(i$.hasNext()) {
         eDef = (EventDefinition)i$.next();
         this.eventManager.deleteEventSourcesForDefinition(eDef);
         this.entityManager.remove(eDef);
      }

   }

   private void updatePluginConfiguration(ResourceType resourceType, ResourceType existingType) {
      ConfigurationDefinition existingConfigurationDefinition = existingType.getPluginConfigurationDefinition();
      if(resourceType.getPluginConfigurationDefinition() != null) {
         if(existingConfigurationDefinition == null) {
            this.entityManager.persist(resourceType.getPluginConfigurationDefinition());
            existingType.setPluginConfigurationDefinition(resourceType.getPluginConfigurationDefinition());
         } else {
            this.configurationMetadataManager.updateConfigurationDefinition(resourceType.getPluginConfigurationDefinition(), existingConfigurationDefinition);
         }
      } else if(existingConfigurationDefinition != null) {
         existingType.setPluginConfigurationDefinition((ConfigurationDefinition)null);
         this.entityManager.remove(existingConfigurationDefinition);
      }

   }

   private void updateProcessScans(ResourceType resourceType, ResourceType existingType) {
      Set existingScans = existingType.getProcessScans();
      Set newScans = resourceType.getProcessScans();
      Set scansToPersist = this.missingInFirstSet(existingScans, newScans);
      Set scansToDelete = this.missingInFirstSet(newScans, existingScans);
      Set scansToUpdate = this.intersection(existingScans, newScans);
      Iterator i$ = scansToUpdate.iterator();

      ProcessScan scan;
      while(i$.hasNext()) {
         scan = (ProcessScan)i$.next();
         Iterator i$1 = newScans.iterator();

         while(i$1.hasNext()) {
            ProcessScan nScan = (ProcessScan)i$1.next();
            if(scan.equals(nScan)) {
               scan.setName(nScan.getName());
            }
         }
      }

      i$ = scansToPersist.iterator();

      while(i$.hasNext()) {
         scan = (ProcessScan)i$.next();
         existingType.addProcessScan(scan);
      }

      i$ = scansToDelete.iterator();

      while(i$.hasNext()) {
         scan = (ProcessScan)i$.next();
         existingScans.remove(scan);
         this.entityManager.remove(scan);
      }

   }

   private void updateOperationDefinitions(ResourceType resourceType, ResourceType existingType) {
      Set existingDefinitions = existingType.getOperationDefinitions();
      Set newDefinitions = resourceType.getOperationDefinitions();
      Set newOps = this.missingInFirstSet(existingDefinitions, newDefinitions);
      Set opsToRemove = this.missingInFirstSet(newDefinitions, existingDefinitions);
      existingDefinitions.retainAll(newDefinitions);
      Iterator i$ = existingDefinitions.iterator();

      OperationDefinition opToDelete;
      while(i$.hasNext()) {
         opToDelete = (OperationDefinition)i$.next();
         Iterator i$1 = newDefinitions.iterator();

         while(i$1.hasNext()) {
            OperationDefinition nDef = (OperationDefinition)i$1.next();
            if(opToDelete.equals(nDef)) {
               opToDelete.setDescription(nDef.getDescription());
               opToDelete.setDisplayName(nDef.getDisplayName());
               opToDelete.setParametersConfigurationDefinition(nDef.getParametersConfigurationDefinition());
               opToDelete.setResourceVersionRange(nDef.getResourceVersionRange());
               opToDelete.setResultsConfigurationDefinition(nDef.getResultsConfigurationDefinition());
               opToDelete.setTimeout(nDef.getTimeout());
            }
         }
      }

      i$ = newOps.iterator();

      while(i$.hasNext()) {
         opToDelete = (OperationDefinition)i$.next();
         existingType.addOperationDefinition(opToDelete);
      }

      existingDefinitions.removeAll(opsToRemove);
      i$ = opsToRemove.iterator();

      while(i$.hasNext()) {
         opToDelete = (OperationDefinition)i$.next();
         this.entityManager.remove(opToDelete);
      }

   }

   private void updateMeasurementDefinitions(ResourceType newType, ResourceType existingType) {
      if(newType.getMetricDefinitions() != null) {
         Set existingDefinitions = existingType.getMetricDefinitions();
         Iterator definitionsToDelete;
         MeasurementDefinition i$;
         if(existingDefinitions.isEmpty()) {
            definitionsToDelete = newType.getMetricDefinitions().iterator();

            while(definitionsToDelete.hasNext()) {
               i$ = (MeasurementDefinition)definitionsToDelete.next();
               if(i$.getDefaultInterval() &lt; 30000L) {
                  i$.setDefaultInterval(30000L);
                  this.log.info(&quot;Definition [&quot; + i$ + &quot;] has too short of a default interval, setting to minimum&quot;);
               }

               existingType.addMetricDefinition(i$);
               this.entityManager.persist(i$);
               this.scheduleManager.createSchedulesForExistingResources(existingType, i$);
            }
         } else {
            definitionsToDelete = newType.getMetricDefinitions().iterator();

            while(definitionsToDelete.hasNext()) {
               i$ = (MeasurementDefinition)definitionsToDelete.next();
               boolean definitionToDelete = false;
               Iterator i$1 = existingDefinitions.iterator();

               while(i$1.hasNext()) {
                  MeasurementDefinition existingDefinition = (MeasurementDefinition)i$1.next();
                  if(existingDefinition.getName().equals(i$.getName()) &amp;&amp; existingDefinition.isPerMinute() == i$.isPerMinute()) {
                     definitionToDelete = true;
                     existingDefinition.update(i$, false);
                     if(existingDefinition.getDefaultInterval() &lt; 30000L) {
                        existingDefinition.setDefaultInterval(30000L);
                        this.log.info(&quot;Definition [&quot; + existingDefinition + &quot;] has too short of a default interval, setting to minimum&quot;);
                     }

                     this.entityManager.merge(existingDefinition);
                     break;
                  }
               }

               if(!definitionToDelete) {
                  existingType.addMetricDefinition(i$);
                  this.entityManager.persist(i$);
                  this.scheduleManager.createSchedulesForExistingResources(existingType, i$);
               }
            }

            ArrayList definitionsToDelete1 = new ArrayList();
            Iterator i$2 = existingDefinitions.iterator();

            MeasurementDefinition definitionToDelete1;
            while(i$2.hasNext()) {
               definitionToDelete1 = (MeasurementDefinition)i$2.next();
               if(!newType.getMetricDefinitions().contains(definitionToDelete1)) {
                  definitionsToDelete1.add(definitionToDelete1);
               }
            }

            existingDefinitions.removeAll(definitionsToDelete1);
            i$2 = definitionsToDelete1.iterator();

            while(i$2.hasNext()) {
               definitionToDelete1 = (MeasurementDefinition)i$2.next();
               this.measurementDefinitionManager.removeMeasurementDefinition(definitionToDelete1);
            }

            if(!definitionsToDelete1.isEmpty() &amp;&amp; this.log.isDebugEnabled()) {
               this.log.debug(&quot;Metadata update: Measurement definitions deleted from resource type [&quot; + existingType.getName() + &quot;]:&quot; + definitionsToDelete1);
            }

            this.entityManager.flush();
         }
      }

   }

   private void updateContentDefinitions(ResourceType newType, ResourceType existingType) {
      if(newType.getPackageTypes() != null &amp;&amp; newType.getPackageTypes().size() != 0) {
         if(existingType.getPackageTypes() != null &amp;&amp; existingType.getPackageTypes().size() != 0) {
            Set existingPackageTypes1 = existingType.getPackageTypes();
            HashMap newPackageTypeDefinitions1 = new HashMap(newType.getPackageTypes().size());
            Iterator removedPackageTypes = newType.getPackageTypes().iterator();

            while(removedPackageTypes.hasNext()) {
               PackageType mergedPackageTypes = (PackageType)removedPackageTypes.next();
               newPackageTypeDefinitions1.put(mergedPackageTypes.getName(), mergedPackageTypes);
            }

            ArrayList removedPackageTypes1 = new ArrayList(existingType.getPackageTypes());
            removedPackageTypes1.removeAll(newType.getPackageTypes());
            Iterator mergedPackageTypes1 = removedPackageTypes1.iterator();

            while(mergedPackageTypes1.hasNext()) {
               PackageType newPackageTypes = (PackageType)mergedPackageTypes1.next();
               existingType.removePackageType(newPackageTypes);
               this.entityManager.remove(newPackageTypes);
            }

            ArrayList mergedPackageTypes2 = new ArrayList(existingType.getPackageTypes());
            mergedPackageTypes2.retainAll(newType.getPackageTypes());
            Iterator newPackageTypes1 = mergedPackageTypes2.iterator();

            while(newPackageTypes1.hasNext()) {
               PackageType i$ = (PackageType)newPackageTypes1.next();
               this.updatePackageConfigurations((PackageType)newPackageTypeDefinitions1.get(i$.getName()), i$);
               i$.update((PackageType)newPackageTypeDefinitions1.get(i$.getName()));
               this.entityManager.merge(i$);
            }

            ArrayList newPackageTypes2 = new ArrayList(newType.getPackageTypes());
            newPackageTypes2.removeAll(existingType.getPackageTypes());
            Iterator i$1 = newPackageTypes2.iterator();

            while(i$1.hasNext()) {
               PackageType newPackageType = (PackageType)i$1.next();
               newPackageType.setResourceType(existingType);
               this.entityManager.persist(newPackageType);
               existingPackageTypes1.add(newPackageType);
            }

         } else {
            Iterator existingPackageTypes = newType.getPackageTypes().iterator();

            while(existingPackageTypes.hasNext()) {
               PackageType newPackageTypeDefinitions = (PackageType)existingPackageTypes.next();
               newPackageTypeDefinitions.setResourceType(existingType);
               this.entityManager.persist(newPackageTypeDefinitions);
            }

            existingType.setPackageTypes(newType.getPackageTypes());
         }
      } else {
         existingType.setPackageTypes((Set)null);
      }
   }

   private void updateChildSubCategories(ResourceType newType, ResourceType existingType) {
      if(existingType.getChildSubCategories() == null) {
         Iterator subCategoriesFromNewType1 = newType.getChildSubCategories().iterator();

         while(subCategoriesFromNewType1.hasNext()) {
            ResourceSubCategory mergedSubCategories2 = (ResourceSubCategory)subCategoriesFromNewType1.next();
            this.log.debug(&quot;Metadata update: Adding new child SubCategory [&quot; + mergedSubCategories2.getName() + &quot;] to ResourceType [&quot; + existingType.getName() + &quot;]...&quot;);
            existingType.addChildSubCategory(mergedSubCategories2);
            this.entityManager.persist(mergedSubCategories2);
         }

      } else {
         HashMap subCategoriesFromNewType = new HashMap(newType.getChildSubCategories().size());
         Iterator mergedSubCategories = newType.getChildSubCategories().iterator();

         while(mergedSubCategories.hasNext()) {
            ResourceSubCategory newSubCategories = (ResourceSubCategory)mergedSubCategories.next();
            subCategoriesFromNewType.put(newSubCategories.getName(), newSubCategories);
         }

         ArrayList mergedSubCategories1 = new ArrayList(existingType.getChildSubCategories());
         mergedSubCategories1.retainAll(subCategoriesFromNewType.values());
         Iterator newSubCategories1 = mergedSubCategories1.iterator();

         while(newSubCategories1.hasNext()) {
            ResourceSubCategory i$ = (ResourceSubCategory)newSubCategories1.next();
            this.updateSubCategory(i$, (ResourceSubCategory)subCategoriesFromNewType.get(i$.getName()));
            this.entityManager.merge(i$);
         }

         ArrayList newSubCategories2 = new ArrayList(newType.getChildSubCategories());
         newSubCategories2.removeAll(existingType.getChildSubCategories());
         Iterator i$1 = newSubCategories2.iterator();

         while(i$1.hasNext()) {
            ResourceSubCategory newSubCat = (ResourceSubCategory)i$1.next();
            this.log.debug(&quot;Metadata update: Adding new child SubCategory [&quot; + newSubCat.getName() + &quot;] to ResourceType [&quot; + existingType.getName() + &quot;]...&quot;);
            existingType.addChildSubCategory(newSubCat);
            this.entityManager.persist(newSubCat);
         }

      }
   }

   private void updateSubCategory(ResourceSubCategory existingSubCat, ResourceSubCategory newSubCategory) {
      existingSubCat.update(newSubCategory);
      if(existingSubCat.getChildSubCategories() != null &amp;&amp; !existingSubCat.getChildSubCategories().isEmpty()) {
         HashMap childSubCategoriesFromNewSubCat1 = new HashMap(newSubCategory.getChildSubCategories().size());
         Iterator mergedChildSubCategories1 = newSubCategory.getChildSubCategories().iterator();

         while(mergedChildSubCategories1.hasNext()) {
            ResourceSubCategory newChildSubCategories = (ResourceSubCategory)mergedChildSubCategories1.next();
            childSubCategoriesFromNewSubCat1.put(newChildSubCategories.getName(), newChildSubCategories);
         }

         ArrayList mergedChildSubCategories2 = new ArrayList(existingSubCat.getChildSubCategories());
         mergedChildSubCategories2.retainAll(childSubCategoriesFromNewSubCat1.values());
         Iterator newChildSubCategories1 = mergedChildSubCategories2.iterator();

         while(newChildSubCategories1.hasNext()) {
            ResourceSubCategory i$ = (ResourceSubCategory)newChildSubCategories1.next();
            this.updateSubCategory(i$, (ResourceSubCategory)childSubCategoriesFromNewSubCat1.get(i$.getName()));
            this.entityManager.merge(i$);
         }

         ArrayList newChildSubCategories2 = new ArrayList(newSubCategory.getChildSubCategories());
         newChildSubCategories2.removeAll(existingSubCat.getChildSubCategories());
         Iterator i$1 = newChildSubCategories2.iterator();

         while(i$1.hasNext()) {
            ResourceSubCategory newChildSubCategory = (ResourceSubCategory)i$1.next();
            this.log.debug(&quot;Metadata update: Adding new child SubCategory [&quot; + newChildSubCategory.getName() + &quot;] to SubCategory [&quot; + existingSubCat.getName() + &quot;]...&quot;);
            existingSubCat.addChildSubCategory(newChildSubCategory);
            this.entityManager.persist(newChildSubCategory);
         }

      } else {
         Iterator childSubCategoriesFromNewSubCat = newSubCategory.getChildSubCategories().iterator();

         while(childSubCategoriesFromNewSubCat.hasNext()) {
            ResourceSubCategory mergedChildSubCategories = (ResourceSubCategory)childSubCategoriesFromNewSubCat.next();
            this.log.debug(&quot;Metadata update: Adding new child SubCategory [&quot; + mergedChildSubCategories.getName() + &quot;] to SubCategory [&quot; + existingSubCat.getName() + &quot;]...&quot;);
            existingSubCat.addChildSubCategory(mergedChildSubCategories);
            this.entityManager.persist(mergedChildSubCategories);
         }

      }
   }

   private void removeSubCategories(ResourceType newType, ResourceType existingType) {
      ArrayList removedSubCategories = new ArrayList(existingType.getChildSubCategories());
      removedSubCategories.removeAll(newType.getChildSubCategories());
      Iterator i$ = removedSubCategories.iterator();

      while(i$.hasNext()) {
         ResourceSubCategory removedSubCat = (ResourceSubCategory)i$.next();
         existingType.getChildSubCategories().remove(removedSubCat);
         this.entityManager.remove(removedSubCat);
      }

      this.removeChildSubCategories(existingType.getChildSubCategories(), newType.getChildSubCategories());
   }

   private void removeChildSubCategories(List existingSubCategories, List newSubCategories) {
      HashMap mapOfNewSubCategories = new HashMap(newSubCategories.size());
      Iterator i$ = newSubCategories.iterator();

      ResourceSubCategory existingSubCat;
      while(i$.hasNext()) {
         existingSubCat = (ResourceSubCategory)i$.next();
         mapOfNewSubCategories.put(existingSubCat.getName(), existingSubCat);
      }

      i$ = existingSubCategories.iterator();

      while(i$.hasNext()) {
         existingSubCat = (ResourceSubCategory)i$.next();
         ArrayList removedChildSubCategories = new ArrayList(existingSubCat.getChildSubCategories());
         List newChildSubCategories = ((ResourceSubCategory)mapOfNewSubCategories.get(existingSubCat.getName())).getChildSubCategories();
         removedChildSubCategories.removeAll(newChildSubCategories);
         Iterator i$1 = removedChildSubCategories.iterator();

         while(i$1.hasNext()) {
            ResourceSubCategory removedChildSubCat = (ResourceSubCategory)i$1.next();
            existingSubCat.removeChildSubCategory(removedChildSubCat);
            this.entityManager.remove(removedChildSubCat);
         }

         this.removeChildSubCategories(existingSubCat.getChildSubCategories(), newChildSubCategories);
      }

   }

   private void updatePackageConfigurations(PackageType newType, PackageType existingType) {
      ConfigurationDefinition newConfigurationDefinition = newType.getDeploymentConfigurationDefinition();
      ConfigurationDefinition existingDefinition;
      if(newConfigurationDefinition != null) {
         if(existingType.getDeploymentConfigurationDefinition() == null) {
            this.entityManager.persist(newConfigurationDefinition);
            existingType.setDeploymentConfigurationDefinition(newConfigurationDefinition);
         } else {
            existingDefinition = existingType.getDeploymentConfigurationDefinition();
            this.configurationMetadataManager.updateConfigurationDefinition(newConfigurationDefinition, existingDefinition);
         }
      } else if(existingType.getDeploymentConfigurationDefinition() != null) {
         existingType.setDeploymentConfigurationDefinition((ConfigurationDefinition)null);
      }

      newConfigurationDefinition = newType.getPackageExtraPropertiesDefinition();
      if(newConfigurationDefinition != null) {
         if(existingType.getPackageExtraPropertiesDefinition() == null) {
            this.entityManager.persist(newConfigurationDefinition);
            existingType.setPackageExtraPropertiesDefinition(newConfigurationDefinition);
         } else {
            existingDefinition = existingType.getPackageExtraPropertiesDefinition();
            this.configurationMetadataManager.updateConfigurationDefinition(newConfigurationDefinition, existingDefinition);
         }
      } else if(existingType.getPackageExtraPropertiesDefinition() != null) {
         existingType.setPackageExtraPropertiesDefinition((ConfigurationDefinition)null);
      }

   }

   private void updateResourceConfiguration(ResourceType newType, ResourceType existingType) {
      ConfigurationDefinition newResourceConfigurationDefinition = newType.getResourceConfigurationDefinition();
      if(newResourceConfigurationDefinition != null) {
         if(existingType.getResourceConfigurationDefinition() == null) {
            this.entityManager.persist(newResourceConfigurationDefinition);
            existingType.setResourceConfigurationDefinition(newResourceConfigurationDefinition);
         } else {
            ConfigurationDefinition existingDefinition = existingType.getResourceConfigurationDefinition();
            this.configurationMetadataManager.updateConfigurationDefinition(newResourceConfigurationDefinition, existingDefinition);
         }
      } else if(existingType.getResourceConfigurationDefinition() != null) {
         existingType.setResourceConfigurationDefinition((ConfigurationDefinition)null);
      }

   }

   private Set missingInFirstSet(Set first, Set reference) {
      HashSet result = new HashSet();
      if(reference != null) {
         if(first == null) {
            result.addAll(reference);
            return result;
         }

         Iterator i$ = reference.iterator();

         while(i$.hasNext()) {
            Object item = i$.next();
            boolean found = false;
            Iterator iter = first.iterator();

            while(iter.hasNext()) {
               Object f = iter.next();
               if(f.equals(item)) {
                  found = true;
                  break;
               }
            }

            if(!found) {
               result.add(item);
            }
         }
      }

      return result;
   }

   private Set intersection(Set first, Set second) {
      HashSet result = new HashSet();
      if(first != null &amp;&amp; second != null) {
         result.addAll(first);
         Iterator iter = result.iterator();

         while(iter.hasNext()) {
            Object item = iter.next();
            boolean found = false;
            Iterator i$ = second.iterator();

            while(i$.hasNext()) {
               Object s = i$.next();
               if(s.equals(item)) {
                  found = true;
               }
            }

            if(!found) {
               iter.remove();
            }
         }
      }

      return result;
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Sep 8, 2017 11:31:16 AM</div>
    <script src="resources/js/jquery-1.10.1.min.js"></script>
    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });




            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4062208;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>

</body>
</html>
