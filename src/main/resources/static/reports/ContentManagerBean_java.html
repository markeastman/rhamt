<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for ContentManagerBean.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />
    <link rel="shortcut icon" href="resources/img/rhamt-icon-128.png" type="image/x-icon"/>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-default navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
              <strong class="wu-navbar-header">Red Hat Application Migration Toolkit</strong>
            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4062208">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.1.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-compressed"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ejbreport_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon ejb-nav-logo"></i>
                      EJBs
                    </a>
                </li>


                <li class="">
                    <a href="jpa_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon jpa-nav-logo"></i>
                      JPA
                    </a>
                </li>


                <li class="">
                    <a href="server_resources_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon server-resource-nav-logo"></i>
                      Server Resources
                    </a>
                </li>


                <li class="">
                    <a href="hardcoded_ipsRHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-map-marker"></i>
                      Hard-coded IP Addresses
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_RHQ_Enterprise_Server_EAR.html">
                        <i class="glyphicon glyphicon-info-sign"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.jboss.org/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report</div>

                        <div class="path project-specific" data-project-id="4062208">
                            rhq-enterprise-server-ear-1.3.0.EmbJopr.1.3.0-4.ear/rhq-enterprise-server-ejb3.jar/org/rhq/enterprise/server/content/ContentManagerBean.java
                        </div>
                </h1>
                <div class="desc">
                    This report displays what Red Hat Application Migration Toolkit found in individual files.
                    Each item is shown below the line it was found on,
                    and next to it, you may find a link to the rule which it was found by.
                </div>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">

                            <h4>Technologies</h4>
                            <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                    <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                            </div>



                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package org.rhq.enterprise.server.content;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.FlushModeType;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.sql.DataSource;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jboss.annotation.ejb.TransactionTimeout;
import org.rhq.core.clientapi.agent.PluginContainerException;
import org.rhq.core.clientapi.agent.content.ContentAgentService;
import org.rhq.core.clientapi.server.content.ContentServiceResponse;
import org.rhq.core.domain.auth.Subject;
import org.rhq.core.domain.authz.Permission;
import org.rhq.core.domain.configuration.Configuration;
import org.rhq.core.domain.content.Architecture;
import org.rhq.core.domain.content.ContentRequestStatus;
import org.rhq.core.domain.content.ContentRequestType;
import org.rhq.core.domain.content.ContentServiceRequest;
import org.rhq.core.domain.content.InstalledPackage;
import org.rhq.core.domain.content.InstalledPackageHistory;
import org.rhq.core.domain.content.InstalledPackageHistoryStatus;
import org.rhq.core.domain.content.Package;
import org.rhq.core.domain.content.PackageBits;
import org.rhq.core.domain.content.PackageDetailsKey;
import org.rhq.core.domain.content.PackageInstallationStep;
import org.rhq.core.domain.content.PackageType;
import org.rhq.core.domain.content.PackageVersion;
import org.rhq.core.domain.content.transfer.ContentDiscoveryReport;
import org.rhq.core.domain.content.transfer.ContentResponseResult;
import org.rhq.core.domain.content.transfer.DeletePackagesRequest;
import org.rhq.core.domain.content.transfer.DeployIndividualPackageResponse;
import org.rhq.core.domain.content.transfer.DeployPackageStep;
import org.rhq.core.domain.content.transfer.DeployPackagesRequest;
import org.rhq.core.domain.content.transfer.DeployPackagesResponse;
import org.rhq.core.domain.content.transfer.RemoveIndividualPackageResponse;
import org.rhq.core.domain.content.transfer.RemovePackagesResponse;
import org.rhq.core.domain.content.transfer.ResourcePackageDetails;
import org.rhq.core.domain.content.transfer.RetrievePackageBitsRequest;
import org.rhq.core.domain.criteria.InstalledPackageCriteria;
import org.rhq.core.domain.criteria.PackageVersionCriteria;
import org.rhq.core.domain.resource.Agent;
import org.rhq.core.domain.resource.ResourceType;
import org.rhq.core.domain.util.CriteriaQueryGenerator;
import org.rhq.core.domain.util.PageList;
import org.rhq.core.domain.util.CriteriaQueryGenerator.AuthorizationTokenType;
import org.rhq.core.util.collection.ArrayUtils;
import org.rhq.core.util.exception.ThrowableUtil;
import org.rhq.core.util.stream.StreamUtil;
import org.rhq.enterprise.server.agentclient.AgentClient;
import org.rhq.enterprise.server.authz.AuthorizationManagerLocal;
import org.rhq.enterprise.server.authz.PermissionException;
import org.rhq.enterprise.server.content.ContentManagerHelper;
import org.rhq.enterprise.server.content.ContentManagerLocal;
import org.rhq.enterprise.server.content.ContentManagerRemote;
import org.rhq.enterprise.server.core.AgentManagerLocal;
import org.rhq.enterprise.server.resource.ResourceTypeManagerLocal;
import org.rhq.enterprise.server.resource.ResourceTypeNotFoundException;

@Stateless
public class ContentManagerBean implements ContentManagerLocal, ContentManagerRemote {
   private static final int REQUEST_TIMEOUT = 3600000;
   private final Log log = LogFactory.getLog(this.getClass());
   @PersistenceContext(
      unitName = &quot;rhqpu&quot;
   )
   private EntityManager entityManager;
   @Resource(
      name = &quot;RHQ_DS&quot;,
      mappedName = &quot;java:/RHQDS&quot;
   )
   private DataSource dataSource;
   @EJB
   private AgentManagerLocal agentManager;
   @EJB
   private AuthorizationManagerLocal authorizationManager;
   @EJB
   private ContentManagerLocal contentManager;
   @EJB
   private ResourceTypeManagerLocal resourceTypeManager;

   public void mergeDiscoveredPackages(ContentDiscoveryReport report) {
      int resourceId = report.getResourceId();
      long start = System.currentTimeMillis();
      this.log.info(&quot;Merging packages for resource ID [&quot; + resourceId + &quot;]. Package count [&quot; + report.getDeployedPackages().size() + &quot;]&quot;);
      org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
      if(resource == null) {
         this.log.error(&quot;Invalid resource ID specified for merge. Resource ID: &quot; + resourceId);
      } else {
         long timestamp = System.currentTimeMillis();
         Query currentInstalledPackageQuery = this.entityManager.createNamedQuery(&quot;InstalledPackage.findByResourceId&quot;);
         currentInstalledPackageQuery.setParameter(&quot;resourceId&quot;, Integer.valueOf(resource.getId()));
         HashSet doomedPackages = new HashSet(currentInstalledPackageQuery.getResultList());
         Iterator deletedPackages = report.getDeployedPackages().iterator();

         while(true) {
            while(deletedPackages.hasNext()) {
               ResourcePackageDetails i$ = (ResourcePackageDetails)deletedPackages.next();
               Query doomedPackage = this.entityManager.createNamedQuery(&quot;Package.findByNamePkgTypeResourceType&quot;);
               doomedPackage.setFlushMode(FlushModeType.COMMIT);
               doomedPackage.setParameter(&quot;name&quot;, i$.getName());
               doomedPackage.setParameter(&quot;packageTypeName&quot;, i$.getPackageTypeName());
               doomedPackage.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resource.getResourceType().getId()));
               List history = doomedPackage.getResultList();
               Package generalPackage = null;
               if(history.size() &gt; 0) {
                  generalPackage = (Package)history.get(0);
               }

               Query packageVersionQuery = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
               packageVersionQuery.setFlushMode(FlushModeType.COMMIT);
               packageVersionQuery.setParameter(&quot;packageName&quot;, i$.getName());
               packageVersionQuery.setParameter(&quot;packageTypeName&quot;, i$.getPackageTypeName());
               packageVersionQuery.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resource.getResourceType().getId()));
               packageVersionQuery.setParameter(&quot;architectureName&quot;, i$.getArchitectureName());
               packageVersionQuery.setParameter(&quot;version&quot;, i$.getVersion());
               List existingPackageVersionList = packageVersionQuery.getResultList();
               PackageVersion packageVersion = null;
               if(existingPackageVersionList.size() &gt; 0) {
                  packageVersion = (PackageVersion)existingPackageVersionList.get(0);
               }

               Query newlyInstalledPackage;
               if(packageVersion == null) {
                  if(generalPackage == null) {
                     newlyInstalledPackage = this.entityManager.createNamedQuery(&quot;PackageType.findByResourceTypeIdAndName&quot;);
                     newlyInstalledPackage.setFlushMode(FlushModeType.COMMIT);
                     newlyInstalledPackage.setParameter(&quot;typeId&quot;, Integer.valueOf(resource.getResourceType().getId()));
                     newlyInstalledPackage.setParameter(&quot;name&quot;, i$.getPackageTypeName());
                     PackageType history1 = (PackageType)newlyInstalledPackage.getSingleResult();
                     generalPackage = new Package(i$.getName(), history1);
                     generalPackage = this.persistOrMergePackageSafely(generalPackage);
                  }

                  newlyInstalledPackage = this.entityManager.createNamedQuery(&quot;Architecture.findByName&quot;);
                  newlyInstalledPackage.setFlushMode(FlushModeType.COMMIT);
                  newlyInstalledPackage.setParameter(&quot;name&quot;, i$.getArchitectureName());

                  Architecture var28;
                  try {
                     var28 = (Architecture)newlyInstalledPackage.getSingleResult();
                  } catch (Exception var22) {
                     this.log.warn(&quot;Could not load architecture for architecture name [&quot; + i$.getArchitectureName() + &quot;] for package [&quot; + i$.getName() + &quot;]. Cause: &quot; + ThrowableUtil.getAllMessages(var22));
                     continue;
                  }

                  packageVersion = new PackageVersion(generalPackage, i$.getVersion(), var28);
                  packageVersion.setDisplayName(i$.getDisplayName());
                  packageVersion.setDisplayVersion(i$.getDisplayVersion());
                  packageVersion.setFileCreatedDate(i$.getFileCreatedDate());
                  packageVersion.setFileName(i$.getFileName());
                  packageVersion.setFileSize(i$.getFileSize());
                  packageVersion.setLicenseName(i$.getLicenseName());
                  packageVersion.setLicenseVersion(i$.getLicenseVersion());
                  packageVersion.setLongDescription(i$.getLongDescription());
                  packageVersion.setMD5(i$.getMD5());
                  packageVersion.setMetadata(i$.getMetadata());
                  packageVersion.setSHA256(i$.getSHA256());
                  packageVersion.setShortDescription(i$.getShortDescription());
                  packageVersion.setExtraProperties(i$.getExtraProperties());
                  packageVersion = this.persistOrMergePackageVersionSafely(packageVersion);
               } else {
                  newlyInstalledPackage = this.entityManager.createNamedQuery(&quot;InstalledPackage.findByResourceAndPackageVer&quot;);
                  newlyInstalledPackage.setFlushMode(FlushModeType.COMMIT);
                  newlyInstalledPackage.setParameter(&quot;resourceId&quot;, Integer.valueOf(resource.getId()));
                  newlyInstalledPackage.setParameter(&quot;packageVersionId&quot;, Integer.valueOf(packageVersion.getId()));
                  List var29 = newlyInstalledPackage.getResultList();
                  if(var29.size() &gt; 0) {
                     if(this.log.isDebugEnabled()) {
                        this.log.debug(&quot;Discovered package is already known to the inventory &quot; + var29.iterator().next());
                     }

                     Iterator i$1 = var29.iterator();

                     while(i$1.hasNext()) {
                        InstalledPackage ip = (InstalledPackage)i$1.next();
                        doomedPackages.remove(ip);
                     }
                     continue;
                  }
               }

               InstalledPackage var27 = new InstalledPackage();
               var27.setPackageVersion(packageVersion);
               var27.setResource(resource);
               var27.setInstallationDate(Long.valueOf(i$.getInstallationTimestamp()));
               this.entityManager.persist(var27);
               InstalledPackageHistory var30 = new InstalledPackageHistory();
               var30.setDeploymentConfigurationValues(i$.getDeploymentTimeConfiguration());
               var30.setPackageVersion(packageVersion);
               var30.setResource(resource);
               var30.setStatus(InstalledPackageHistoryStatus.DISCOVERED);
               var30.setTimestamp(Long.valueOf(timestamp));
               this.entityManager.persist(var30);
               this.entityManager.flush();
            }

            int var23 = 0;
            Iterator var24 = doomedPackages.iterator();

            while(var24.hasNext()) {
               InstalledPackage var25 = (InstalledPackage)var24.next();
               var25 = (InstalledPackage)this.entityManager.find(InstalledPackage.class, Integer.valueOf(var25.getId()));
               InstalledPackageHistory var26 = new InstalledPackageHistory();
               var26.setPackageVersion(var25.getPackageVersion());
               var26.setResource(resource);
               var26.setStatus(InstalledPackageHistoryStatus.MISSING);
               var26.setTimestamp(Long.valueOf(timestamp));
               this.entityManager.persist(var26);
               this.entityManager.remove(var25);
               ++var23;
               if(var23 % 100 == 0) {
                  this.entityManager.flush();
               }
            }

            this.log.info(&quot;Finished merging &quot; + report.getDeployedPackages().size() + &quot; packages in &quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
            return;
         }
      }
   }

   public void deployPackages(Subject user, int[] resourceIds, int[] packageVersionIds) {
      int[] arr$ = resourceIds;
      int len$ = resourceIds.length;

      for(int i$ = 0; i$ &lt; len$; ++i$) {
         int resourceId = arr$[i$];
         HashSet packages = new HashSet();
         int[] arr$1 = packageVersionIds;
         int len$1 = packageVersionIds.length;

         for(int i$1 = 0; i$1 &lt; len$1; ++i$1) {
            int packageVersionId = arr$1[i$1];
            PackageVersion packageVersion = (PackageVersion)this.entityManager.find(PackageVersion.class, Integer.valueOf(packageVersionId));
            if(packageVersion == null) {
               throw new IllegalArgumentException(&quot;PackageVersion: [&quot; + packageVersionId + &quot;] not found!&quot;);
            }

            PackageDetailsKey key = new PackageDetailsKey(packageVersion.getGeneralPackage().getName(), packageVersion.getVersion(), packageVersion.getGeneralPackage().getPackageType().getName(), packageVersion.getArchitecture().getName());
            ResourcePackageDetails details = new ResourcePackageDetails(key);
            packages.add(details);
         }

         this.deployPackages(user, resourceId, packages, (String)null);
      }

   }

   public void deployPackages(Subject user, int resourceId, Set packages, String requestNotes) {
      if(packages == null) {
         throw new IllegalArgumentException(&quot;packages cannot be null&quot;);
      } else {
         this.log.info(&quot;Deploying &quot; + packages.size() + &quot; packages on resource ID [&quot; + resourceId + &quot;]&quot;);
         if(packages.size() != 0) {
            if(!this.authorizationManager.hasResourcePermission(user, Permission.MANAGE_CONTENT, resourceId)) {
               throw new PermissionException(&quot;User [&quot; + user.getName() + &quot;] does not have permission to deploy packages for resource ID [&quot; + resourceId + &quot;]&quot;);
            } else {
               org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
               Agent agent = resource.getAgent();
               ContentServiceRequest persistedRequest = this.contentManager.createDeployRequest(resourceId, user.getName(), packages, requestNotes);
               DeployPackagesRequest transferRequest = new DeployPackagesRequest(persistedRequest.getId(), resourceId, packages);

               try {
                  AgentClient e = this.agentManager.getAgentClient(agent);
                  ContentAgentService agentService = e.getContentAgentService();
                  agentService.deployPackages(transferRequest);
               } catch (RuntimeException var11) {
                  this.log.error(&quot;Error while sending deploy request to agent&quot;, var11);
                  this.contentManager.failRequest(persistedRequest.getId(), var11);
                  throw var11;
               }
            }
         }
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public ContentServiceRequest createDeployRequest(int resourceId, String username, Set packages, String notes) {
      org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
      ContentServiceRequest persistedRequest = new ContentServiceRequest(resource, username, ContentRequestType.DEPLOY);
      persistedRequest.setStatus(ContentRequestStatus.IN_PROGRESS);
      persistedRequest.setNotes(notes);
      long timestamp = System.currentTimeMillis();
      Iterator i$ = packages.iterator();

      while(i$.hasNext()) {
         ResourcePackageDetails packageDetails = (ResourcePackageDetails)i$.next();
         PackageDetailsKey key = packageDetails.getKey();
         Query packageVersionQuery = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
         packageVersionQuery.setParameter(&quot;packageName&quot;, key.getName());
         packageVersionQuery.setParameter(&quot;packageTypeName&quot;, key.getPackageTypeName());
         packageVersionQuery.setParameter(&quot;architectureName&quot;, key.getArchitectureName());
         packageVersionQuery.setParameter(&quot;version&quot;, key.getVersion());
         packageVersionQuery.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resource.getResourceType().getId()));
         PackageVersion packageVersion = (PackageVersion)packageVersionQuery.getSingleResult();
         InstalledPackageHistory history = new InstalledPackageHistory();
         history.setContentServiceRequest(persistedRequest);
         history.setDeploymentConfigurationValues(packageDetails.getDeploymentTimeConfiguration());
         history.setPackageVersion(packageVersion);
         history.setResource(resource);
         history.setStatus(InstalledPackageHistoryStatus.BEING_INSTALLED);
         history.setTimestamp(Long.valueOf(timestamp));
         persistedRequest.addInstalledPackageHistory(history);
      }

      this.entityManager.persist(persistedRequest);
      return persistedRequest;
   }

   public void completeDeployPackageRequest(DeployPackagesResponse response) {
      this.log.info(&quot;Completing deploy package response: &quot; + response);
      Query query = this.entityManager.createNamedQuery(&quot;ContentServiceRequest.findById&quot;);
      query.setParameter(&quot;id&quot;, Integer.valueOf(response.getRequestId()));
      ContentServiceRequest persistedRequest = (ContentServiceRequest)query.getSingleResult();
      org.rhq.core.domain.resource.Resource resource = persistedRequest.getResource();
      int resourceTypeId = persistedRequest.getResource().getResourceType().getId();
      persistedRequest.setErrorMessage(response.getOverallRequestErrorMessage());
      persistedRequest.setStatus(this.translateRequestResultStatus(response.getOverallRequestResult()));
      Set requestInProgressEntries = persistedRequest.getInstalledPackageHistory();
      HashMap inProgressEntries = new HashMap(requestInProgressEntries.size());
      Iterator timestamp = requestInProgressEntries.iterator();

      while(timestamp.hasNext()) {
         InstalledPackageHistory history = (InstalledPackageHistory)timestamp.next();
         inProgressEntries.put(history.getPackageVersion(), history);
      }

      long timestamp1 = System.currentTimeMillis();
      Iterator i$ = response.getPackageResponses().iterator();

      while(i$.hasNext()) {
         DeployIndividualPackageResponse unclosed = (DeployIndividualPackageResponse)i$.next();
         PackageDetailsKey packageVersion = unclosed.getKey();
         Query history1 = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
         history1.setParameter(&quot;packageName&quot;, packageVersion.getName());
         history1.setParameter(&quot;packageTypeName&quot;, packageVersion.getPackageTypeName());
         history1.setParameter(&quot;architectureName&quot;, packageVersion.getArchitectureName());
         history1.setParameter(&quot;version&quot;, packageVersion.getVersion());
         history1.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resourceTypeId));
         PackageVersion packageVersion1 = (PackageVersion)history1.getSingleResult();
         InstalledPackageHistory history2 = new InstalledPackageHistory();
         history2.setContentServiceRequest(persistedRequest);
         history2.setPackageVersion(packageVersion1);
         history2.setResource(resource);
         history2.setTimestamp(Long.valueOf(timestamp1));
         Query deploymentConfigurationQuery = this.entityManager.createNamedQuery(&quot;InstalledPackageHistory.findConfigByPackageVersionAndReq&quot;);
         deploymentConfigurationQuery.setParameter(&quot;packageVersion&quot;, packageVersion1);
         deploymentConfigurationQuery.setParameter(&quot;contentServiceRequest&quot;, persistedRequest);
         deploymentConfigurationQuery.setMaxResults(1);
         Configuration deploymentConfiguration = null;
         List deploymentConfigurationResults = deploymentConfigurationQuery.getResultList();
         if(deploymentConfigurationResults.size() &gt; 0) {
            deploymentConfiguration = (Configuration)deploymentConfigurationResults.get(0);
            deploymentConfiguration = deploymentConfiguration.deepCopy(false);
         }

         history2.setDeploymentConfigurationValues(deploymentConfiguration);
         List transferObjectSteps = unclosed.getDeploymentSteps();
         if(transferObjectSteps != null) {
            List installationSteps = this.translateInstallationSteps(transferObjectSteps, history2);
            history2.setInstallationSteps(installationSteps);
         }

         if(unclosed.getResult() == ContentResponseResult.SUCCESS) {
            history2.setStatus(InstalledPackageHistoryStatus.INSTALLED);
         } else {
            history2.setStatus(InstalledPackageHistoryStatus.FAILED);
            history2.setErrorMessage(unclosed.getErrorMessage());
         }

         this.entityManager.persist(history2);
         persistedRequest.addInstalledPackageHistory(history2);
         inProgressEntries.remove(packageVersion1);
      }

      i$ = inProgressEntries.values().iterator();

      while(i$.hasNext()) {
         InstalledPackageHistory unclosed1 = (InstalledPackageHistory)i$.next();
         PackageVersion packageVersion2 = unclosed1.getPackageVersion();
         InstalledPackageHistory history3 = new InstalledPackageHistory();
         history3.setContentServiceRequest(persistedRequest);
         history3.setPackageVersion(packageVersion2);
         history3.setResource(resource);
         history3.setTimestamp(Long.valueOf(timestamp1));
         if(response.getOverallRequestResult() == ContentResponseResult.SUCCESS) {
            history3.setStatus(InstalledPackageHistoryStatus.INSTALLED);
         } else {
            history3.setStatus(InstalledPackageHistoryStatus.FAILED);
         }

         this.entityManager.persist(history3);
         persistedRequest.addInstalledPackageHistory(history3);
      }

   }

   public void deletePackages(Subject user, int[] resourceIds, int[] installedPackageIds) {
      int[] arr$ = resourceIds;
      int len$ = resourceIds.length;

      for(int i$ = 0; i$ &lt; len$; ++i$) {
         int resourceId = arr$[i$];
         this.deletePackages(user, resourceId, installedPackageIds, (String)null);
      }

   }

   public void deletePackages(Subject user, int resourceId, int[] installedPackageIds, String requestNotes) {
      if(installedPackageIds == null) {
         throw new IllegalArgumentException(&quot;installedPackages cannot be null&quot;);
      } else {
         this.log.info(&quot;Deleting &quot; + installedPackageIds.length + &quot; from resource ID [&quot; + resourceId + &quot;]&quot;);
         if(installedPackageIds.length != 0) {
            if(!this.authorizationManager.hasResourcePermission(user, Permission.MANAGE_CONTENT, resourceId)) {
               throw new PermissionException(&quot;User [&quot; + user.getName() + &quot;] does not have permission to delete installedPackageIds from resource ID [&quot; + resourceId + &quot;]&quot;);
            } else {
               org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
               Agent agent = resource.getAgent();
               ContentServiceRequest persistedRequest = this.contentManager.createRemoveRequest(resourceId, user.getName(), installedPackageIds, requestNotes);
               Query query = this.entityManager.createNamedQuery(&quot;InstalledPackage.findBySetOfIds&quot;);
               query.setParameter(&quot;packageIds&quot;, ArrayUtils.wrapInList(installedPackageIds));
               List installedPackageList = query.getResultList();
               HashSet transferPackages = new HashSet(installedPackageList.size());
               Iterator transferRequest = installedPackageList.iterator();

               while(transferRequest.hasNext()) {
                  InstalledPackage e = (InstalledPackage)transferRequest.next();
                  ResourcePackageDetails agentService = ContentManagerHelper.installedPackageToDetails(e);
                  transferPackages.add(agentService);
               }

               DeletePackagesRequest transferRequest1 = new DeletePackagesRequest(persistedRequest.getId(), resourceId, transferPackages);

               try {
                  AgentClient e1 = this.agentManager.getAgentClient(agent);
                  ContentAgentService agentService1 = e1.getContentAgentService();
                  agentService1.deletePackages(transferRequest1);
               } catch (RuntimeException var14) {
                  this.log.error(&quot;Error while sending deploy request to agent&quot;, var14);
                  this.contentManager.failRequest(persistedRequest.getId(), var14);
                  throw var14;
               }
            }
         }
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public ContentServiceRequest createRemoveRequest(int resourceId, String username, int[] installedPackageIds, String requestNotes) {
      org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
      ContentServiceRequest persistedRequest = new ContentServiceRequest(resource, username, ContentRequestType.DELETE);
      persistedRequest.setStatus(ContentRequestStatus.IN_PROGRESS);
      persistedRequest.setNotes(requestNotes);
      long timestamp = System.currentTimeMillis();
      int[] arr$ = installedPackageIds;
      int len$ = installedPackageIds.length;

      for(int i$ = 0; i$ &lt; len$; ++i$) {
         int installedPackageId = arr$[i$];
         InstalledPackage ip = (InstalledPackage)this.entityManager.find(InstalledPackage.class, Integer.valueOf(installedPackageId));
         PackageVersion packageVersion = ip.getPackageVersion();
         InstalledPackageHistory history = new InstalledPackageHistory();
         history.setContentServiceRequest(persistedRequest);
         history.setPackageVersion(packageVersion);
         history.setResource(resource);
         history.setStatus(InstalledPackageHistoryStatus.BEING_DELETED);
         history.setTimestamp(Long.valueOf(timestamp));
         persistedRequest.addInstalledPackageHistory(history);
      }

      this.entityManager.persist(persistedRequest);
      return persistedRequest;
   }

   public void completeDeletePackageRequest(RemovePackagesResponse response) {
      this.log.info(&quot;Completing delete package response: &quot; + response);
      Query query = this.entityManager.createNamedQuery(&quot;ContentServiceRequest.findById&quot;);
      query.setParameter(&quot;id&quot;, Integer.valueOf(response.getRequestId()));
      ContentServiceRequest persistedRequest = (ContentServiceRequest)query.getSingleResult();
      org.rhq.core.domain.resource.Resource resource = persistedRequest.getResource();
      int resourceTypeId = resource.getResourceType().getId();
      persistedRequest.setErrorMessage(response.getOverallRequestErrorMessage());
      persistedRequest.setStatus(this.translateRequestResultStatus(response.getOverallRequestResult()));
      Set requestInProgressEntries = persistedRequest.getInstalledPackageHistory();
      HashMap inProgressEntries = new HashMap(requestInProgressEntries.size());
      Iterator timestamp = requestInProgressEntries.iterator();

      while(timestamp.hasNext()) {
         InstalledPackageHistory history = (InstalledPackageHistory)timestamp.next();
         inProgressEntries.put(history.getPackageVersion(), history);
      }

      long timestamp1 = System.currentTimeMillis();
      Iterator i$ = response.getPackageResponses().iterator();

      while(i$.hasNext()) {
         RemoveIndividualPackageResponse unclosed = (RemoveIndividualPackageResponse)i$.next();
         PackageDetailsKey packageVersion = unclosed.getKey();
         Query history1 = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
         history1.setParameter(&quot;packageName&quot;, packageVersion.getName());
         history1.setParameter(&quot;packageTypeName&quot;, packageVersion.getPackageTypeName());
         history1.setParameter(&quot;architectureName&quot;, packageVersion.getArchitectureName());
         history1.setParameter(&quot;version&quot;, packageVersion.getVersion());
         history1.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resourceTypeId));
         PackageVersion packageVersion1 = (PackageVersion)history1.getSingleResult();
         InstalledPackageHistory history2 = new InstalledPackageHistory();
         history2.setContentServiceRequest(persistedRequest);
         history2.setPackageVersion(packageVersion1);
         history2.setResource(resource);
         history2.setTimestamp(Long.valueOf(timestamp1));
         if(unclosed.getResult() == ContentResponseResult.SUCCESS) {
            history2.setStatus(InstalledPackageHistoryStatus.DELETED);
         } else {
            history2.setStatus(InstalledPackageHistoryStatus.FAILED);
            history2.setErrorMessage(unclosed.getErrorMessage());
         }

         this.entityManager.persist(history2);
         persistedRequest.addInstalledPackageHistory(history2);
         inProgressEntries.remove(packageVersion1);
      }

      i$ = inProgressEntries.values().iterator();

      while(i$.hasNext()) {
         InstalledPackageHistory unclosed1 = (InstalledPackageHistory)i$.next();
         PackageVersion packageVersion2 = unclosed1.getPackageVersion();
         InstalledPackageHistory history3 = new InstalledPackageHistory();
         history3.setContentServiceRequest(persistedRequest);
         history3.setPackageVersion(packageVersion2);
         history3.setResource(resource);
         history3.setTimestamp(Long.valueOf(timestamp1));
         if(response.getOverallRequestResult() == ContentResponseResult.SUCCESS) {
            history3.setStatus(InstalledPackageHistoryStatus.DELETED);
         } else {
            history3.setStatus(InstalledPackageHistoryStatus.FAILED);
         }

         this.entityManager.persist(history3);
         persistedRequest.addInstalledPackageHistory(history3);
      }

   }

   public void retrieveBitsFromResource(Subject user, int resourceId, int installedPackageId) {
      this.log.info(&quot;Retrieving bits for package [&quot; + installedPackageId + &quot;] on resource ID [&quot; + resourceId + &quot;]&quot;);
      if(!this.authorizationManager.hasResourcePermission(user, Permission.MANAGE_CONTENT, resourceId)) {
         throw new PermissionException(&quot;User [&quot; + user.getName() + &quot;] does not have permission to delete package &quot; + installedPackageId + &quot; for resource ID [&quot; + resourceId + &quot;]&quot;);
      } else {
         org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
         Agent agent = resource.getAgent();
         InstalledPackage installedPackage = (InstalledPackage)this.entityManager.find(InstalledPackage.class, Integer.valueOf(installedPackageId));
         ContentServiceRequest persistedRequest = this.contentManager.createRetrieveBitsRequest(resourceId, user.getName(), installedPackageId);
         ResourcePackageDetails transferPackage = ContentManagerHelper.installedPackageToDetails(installedPackage);
         RetrievePackageBitsRequest transferRequest = new RetrievePackageBitsRequest(persistedRequest.getId(), resourceId, transferPackage);

         try {
            AgentClient e = this.agentManager.getAgentClient(agent);
            ContentAgentService agentService = e.getContentAgentService();
            agentService.retrievePackageBits(transferRequest);
         } catch (RuntimeException var12) {
            this.log.error(&quot;Error while sending deploy request to agent&quot;, var12);
            this.contentManager.failRequest(persistedRequest.getId(), var12);
            throw var12;
         }
      }
   }

   public byte[] getPackageBytes(Subject user, int resourceId, int installedPackageId) {
      if(!this.authorizationManager.hasResourcePermission(user, Permission.MANAGE_CONTENT, resourceId)) {
         throw new PermissionException(&quot;User [&quot; + user.getName() + &quot;] does not have permission to obtain package content for installed package id [&quot; + installedPackageId + &quot;] for resource ID [&quot; + resourceId + &quot;]&quot;);
      } else {
         InstalledPackage installedPackage = (InstalledPackage)this.entityManager.find(InstalledPackage.class, Integer.valueOf(installedPackageId));
         PackageBits bits = installedPackage.getPackageVersion().getPackageBits();
         if(bits == null) {
            this.retrieveBitsFromResource(user, resourceId, installedPackageId);
            bits = installedPackage.getPackageVersion().getPackageBits();
         }

         return bits.getBits();
      }
   }

   public List translateInstallationSteps(int resourceId, ResourcePackageDetails packageDetails) throws Exception {
      this.log.info(&quot;Retrieving installation steps for package [&quot; + packageDetails + &quot;]&quot;);
      org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
      Agent agent = resource.getAgent();

      try {
         AgentClient e = this.agentManager.getAgentClient(agent);
         ContentAgentService agentService = e.getContentAgentService();
         List packageStepList = agentService.translateInstallationSteps(resourceId, packageDetails);
         return packageStepList;
      } catch (PluginContainerException var8) {
         this.log.error(&quot;Error while sending deploy request to agent&quot;, var8);
         throw var8;
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public ContentServiceRequest createRetrieveBitsRequest(int resourceId, String username, int installedPackageId) {
      org.rhq.core.domain.resource.Resource resource = (org.rhq.core.domain.resource.Resource)this.entityManager.find(org.rhq.core.domain.resource.Resource.class, Integer.valueOf(resourceId));
      ContentServiceRequest persistedRequest = new ContentServiceRequest(resource, username, ContentRequestType.GET_BITS);
      persistedRequest.setStatus(ContentRequestStatus.IN_PROGRESS);
      long timestamp = System.currentTimeMillis();
      InstalledPackage ip = (InstalledPackage)this.entityManager.find(InstalledPackage.class, Integer.valueOf(installedPackageId));
      PackageVersion packageVersion = ip.getPackageVersion();
      InstalledPackageHistory history = new InstalledPackageHistory();
      history.setContentServiceRequest(persistedRequest);
      history.setPackageVersion(packageVersion);
      history.setResource(resource);
      history.setStatus(InstalledPackageHistoryStatus.BEING_RETRIEVED);
      history.setTimestamp(Long.valueOf(timestamp));
      persistedRequest.addInstalledPackageHistory(history);
      this.entityManager.persist(persistedRequest);
      return persistedRequest;
   }

   @TransactionTimeout(2700)
   public void completeRetrievePackageBitsRequest(ContentServiceResponse response, InputStream bitStream) {
      this.log.info(&quot;Completing retrieve package bits response: &quot; + response);
      ContentServiceRequest persistedRequest = (ContentServiceRequest)this.entityManager.find(ContentServiceRequest.class, Integer.valueOf(response.getRequestId()));
      if(persistedRequest == null) {
         this.log.error(&quot;Attempting to complete a request that was not found in the database: &quot; + response.getRequestId());
      } else {
         org.rhq.core.domain.resource.Resource resource = persistedRequest.getResource();
         InstalledPackageHistory initialRequestHistory = (InstalledPackageHistory)persistedRequest.getInstalledPackageHistory().iterator().next();
         PackageVersion packageVersion = initialRequestHistory.getPackageVersion();
         if(response.getStatus() == ContentRequestStatus.SUCCESS) {
            try {
               this.log.debug(&quot;Saving content for response: &quot; + response);
               PackageBits completedHistory = new PackageBits();
               this.entityManager.persist(completedHistory);
               packageVersion.setPackageBits(completedHistory);
               this.entityManager.flush();
               Connection conn = null;
               PreparedStatement ps = null;

               try {
                  conn = this.dataSource.getConnection();
                  ps = conn.prepareStatement(&quot;UPDATE RHQ_PACKAGE_BITS SET BITS = ? WHERE ID = ?&quot;);
                  ps.setBinaryStream(1, bitStream, packageVersion.getFileSize().intValue());
                  ps.setInt(2, completedHistory.getId());
                  if(ps.executeUpdate() != 1) {
                     throw new SQLException(&quot;Did not stream the package bits to the DB for [&quot; + packageVersion + &quot;]&quot;);
                  }
               } finally {
                  if(ps != null) {
                     try {
                        ps.close();
                     } catch (Exception var20) {
                        this.log.warn(&quot;Failed to close prepared statement for package version [&quot; + packageVersion + &quot;]&quot;);
                     }
                  }

                  if(conn != null) {
                     try {
                        conn.close();
                     } catch (Exception var19) {
                        this.log.warn(&quot;Failed to close connection for package version [&quot; + packageVersion + &quot;]&quot;);
                     }
                  }

               }
            } catch (SQLException var22) {
               this.log.error(&quot;Error while reading content from agent stream&quot;, var22);
            }
         }

         persistedRequest.setErrorMessage(response.getErrorMessage());
         persistedRequest.setStatus(response.getStatus());
         InstalledPackageHistory completedHistory1 = new InstalledPackageHistory();
         completedHistory1.setContentServiceRequest(persistedRequest);
         completedHistory1.setResource(resource);
         completedHistory1.setTimestamp(Long.valueOf(System.currentTimeMillis()));
         completedHistory1.setPackageVersion(packageVersion);
         if(response.getStatus() == ContentRequestStatus.SUCCESS) {
            completedHistory1.setStatus(InstalledPackageHistoryStatus.RETRIEVED);
         } else {
            completedHistory1.setStatus(InstalledPackageHistoryStatus.FAILED);
            completedHistory1.setErrorMessage(response.getErrorMessage());
         }

      }
   }

   public Set loadDependencies(int requestId, Set keys) {
      HashSet dependencies = new HashSet();
      ContentServiceRequest persistedRequest = (ContentServiceRequest)this.entityManager.find(ContentServiceRequest.class, Integer.valueOf(requestId));
      if(persistedRequest == null) {
         this.log.error(&quot;Could not find request with ID: &quot; + requestId);
         return dependencies;
      } else {
         org.rhq.core.domain.resource.Resource resource = persistedRequest.getResource();
         ResourceType resourceType = resource.getResourceType();
         long installationDate = System.currentTimeMillis();
         Iterator i$ = keys.iterator();

         while(i$.hasNext()) {
            PackageDetailsKey key = (PackageDetailsKey)i$.next();
            Query packageQuery = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
            packageQuery.setParameter(&quot;packageName&quot;, key.getName());
            packageQuery.setParameter(&quot;packageTypeName&quot;, key.getPackageTypeName());
            packageQuery.setParameter(&quot;architectureName&quot;, key.getArchitectureName());
            packageQuery.setParameter(&quot;version&quot;, key.getVersion());
            packageQuery.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(resourceType.getId()));
            List persistedPackageList = packageQuery.getResultList();
            if(persistedPackageList.size() != 0) {
               if(persistedPackageList.size() != 1) {
                  this.log.error(&quot;Multiple packages found. Found: &quot; + persistedPackageList.size() + &quot; for key: &quot; + key);
               }

               PackageVersion packageVersion = (PackageVersion)persistedPackageList.get(0);
               ResourcePackageDetails details = ContentManagerHelper.packageVersionToDetails(packageVersion);
               dependencies.add(details);
               InstalledPackageHistory dependencyPackage = new InstalledPackageHistory();
               dependencyPackage.setContentServiceRequest(persistedRequest);
               dependencyPackage.setPackageVersion(packageVersion);
               dependencyPackage.setResource(resource);
               dependencyPackage.setStatus(InstalledPackageHistoryStatus.BEING_INSTALLED);
               dependencyPackage.setTimestamp(Long.valueOf(installationDate));
               persistedRequest.addInstalledPackageHistory(dependencyPackage);
               this.entityManager.persist(dependencyPackage);
            }
         }

         return dependencies;
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public void failRequest(int requestId, Throwable error) {
      Query query = this.entityManager.createNamedQuery(&quot;ContentServiceRequest.findById&quot;);
      query.setParameter(&quot;id&quot;, Integer.valueOf(requestId));
      ContentServiceRequest persistedRequest = (ContentServiceRequest)query.getSingleResult();
      org.rhq.core.domain.resource.Resource resource = persistedRequest.getResource();
      persistedRequest.setErrorMessageFromThrowable(error);
      persistedRequest.setStatus(ContentRequestStatus.FAILURE);
      long timestamp = System.currentTimeMillis();
      Iterator i$ = persistedRequest.getInstalledPackageHistory().iterator();

      while(i$.hasNext()) {
         InstalledPackageHistory history = (InstalledPackageHistory)i$.next();
         InstalledPackageHistory failedEntry = new InstalledPackageHistory();
         failedEntry.setContentServiceRequest(persistedRequest);
         failedEntry.setDeploymentConfigurationValues(history.getDeploymentConfigurationValues());
         failedEntry.setErrorMessageFromThrowable(error);
         failedEntry.setPackageVersion(history.getPackageVersion());
         failedEntry.setResource(resource);
         failedEntry.setStatus(InstalledPackageHistoryStatus.FAILED);
         failedEntry.setTimestamp(Long.valueOf(timestamp));
         persistedRequest.addInstalledPackageHistory(failedEntry);
      }

   }

   public List findArchitectures(Subject subject) {
      Query q = this.entityManager.createNamedQuery(&quot;Architecture.findAll&quot;);
      List architectures = q.getResultList();
      return architectures;
   }

   public Architecture getNoArchitecture() {
      Query q = this.entityManager.createNamedQuery(&quot;Architecture.findByName&quot;);
      q.setParameter(&quot;name&quot;, &quot;noarch&quot;);
      Architecture architecture = (Architecture)q.getSingleResult();
      return architecture;
   }

   public List findPackageTypes(Subject subject, String resourceTypeName, String pluginName) throws ResourceTypeNotFoundException {
      ResourceType rt = this.resourceTypeManager.getResourceTypeByNameAndPlugin(resourceTypeName, pluginName);
      if(null == rt) {
         throw new ResourceTypeNotFoundException(resourceTypeName);
      } else {
         Query query = this.entityManager.createNamedQuery(&quot;PackageType.findByResourceTypeId&quot;);
         query.setParameter(&quot;typeId&quot;, Integer.valueOf(rt.getId()));
         List result = query.getResultList();
         return result;
      }
   }

   public void checkForTimedOutRequests(Subject subject) {
      if(!this.authorizationManager.isOverlord(subject)) {
         this.log.debug(&quot;Unauthorized user &quot; + subject + &quot; tried to execute checkForTimedOutRequests; &quot; + &quot;only the overlord may execute this system operation&quot;);
      } else {
         try {
            Query e = this.entityManager.createNamedQuery(&quot;ContentServiceRequest.findWithStatus&quot;);
            e.setParameter(&quot;status&quot;, ContentRequestStatus.IN_PROGRESS);
            List inProgressRequests = e.getResultList();
            if(inProgressRequests != null) {
               long timestamp = System.currentTimeMillis();
               Iterator i$ = inProgressRequests.iterator();

               while(true) {
                  ContentServiceRequest request;
                  long duration;
                  do {
                     if(!i$.hasNext()) {
                        return;
                     }

                     request = (ContentServiceRequest)i$.next();
                     duration = request.getDuration();
                  } while(duration &lt;= 3600000L);

                  this.log.debug(&quot;Timing out request after duration: &quot; + duration + &quot; Request: &quot; + request);
                  request.setErrorMessage(&quot;Request with duration &quot; + duration + &quot; exceeded the timeout threshold of &quot; + 3600000);
                  request.setStatus(ContentRequestStatus.TIMED_OUT);
                  org.rhq.core.domain.resource.Resource resource = request.getResource();
                  Set requestPackages = request.getInstalledPackageHistory();
                  Iterator i$1 = requestPackages.iterator();

                  while(i$1.hasNext()) {
                     InstalledPackageHistory history = (InstalledPackageHistory)i$1.next();
                     InstalledPackageHistoryStatus packageStatus = history.getStatus();
                     switch(ContentManagerBean.SyntheticClass_1.$SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus[packageStatus.ordinal()]) {
                     case 1:
                     case 2:
                     case 3:
                        InstalledPackageHistory closedHistory = new InstalledPackageHistory();
                        closedHistory.setContentServiceRequest(request);
                        closedHistory.setPackageVersion(history.getPackageVersion());
                        closedHistory.setResource(resource);
                        closedHistory.setStatus(InstalledPackageHistoryStatus.TIMED_OUT);
                        closedHistory.setTimestamp(Long.valueOf(timestamp));
                        this.entityManager.persist(closedHistory);
                        break;
                     default:
                        this.log.warn(&quot;Found a history entry on the request with an unexpected status. Id: &quot; + history.getId() + &quot;, Status: &quot; + packageStatus);
                     }
                  }
               }
            }
         } catch (Throwable var16) {
            this.log.error(&quot;Error while processing timed out requests&quot;, var16);
         }
      }
   }

   public PackageVersion createPackageVersion(Subject subject, String packageName, int packageTypeId, String version, int architectureId, byte[] packageBytes) {
      if(!this.authorizationManager.hasGlobalPermission(subject, Permission.MANAGE_CONTENT)) {
         throw new PermissionException(&quot;User [&quot; + subject.getName() + &quot;] does not have permission to create package versions&quot;);
      } else {
         return this.createPackageVersion(packageName, packageTypeId, version, architectureId, new ByteArrayInputStream(packageBytes));
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public PackageVersion createPackageVersion(String packageName, int packageTypeId, String version, int architectureId, InputStream packageBitStream) {
      Query packageVersionQuery = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageVerArch&quot;);
      packageVersionQuery.setParameter(&quot;name&quot;, packageName);
      packageVersionQuery.setParameter(&quot;packageTypeId&quot;, Integer.valueOf(packageTypeId));
      packageVersionQuery.setParameter(&quot;architectureId&quot;, Integer.valueOf(architectureId));
      packageVersionQuery.setParameter(&quot;version&quot;, version);
      List existingVersionList = packageVersionQuery.getResultList();
      if(existingVersionList.size() &gt; 0) {
         return (PackageVersion)existingVersionList.get(0);
      } else {
         Query packageQuery = this.entityManager.createNamedQuery(&quot;Package.findByNameAndPkgTypeId&quot;);
         packageQuery.setParameter(&quot;name&quot;, packageName);
         packageQuery.setParameter(&quot;packageTypeId&quot;, Integer.valueOf(packageTypeId));
         List existingPackageList = packageQuery.getResultList();
         Package existingPackage;
         if(existingPackageList.size() == 0) {
            PackageType architecture = (PackageType)this.entityManager.find(PackageType.class, Integer.valueOf(packageTypeId));
            existingPackage = new Package(packageName, architecture);
            existingPackage = this.persistOrMergePackageSafely(existingPackage);
         } else {
            existingPackage = (Package)existingPackageList.get(0);
         }

         Architecture architecture1 = (Architecture)this.entityManager.find(Architecture.class, Integer.valueOf(architectureId));
         PackageVersion newPackageVersion = new PackageVersion(existingPackage, version, architecture1);
         newPackageVersion.setDisplayName(existingPackage.getName());

         byte[] packageBits;
         try {
            packageBits = StreamUtil.slurp(packageBitStream);
         } catch (RuntimeException var15) {
            throw new RuntimeException(&quot;Error reading in the package file&quot;, var15);
         }

         PackageBits bits = new PackageBits();
         bits.setBits(packageBits);
         newPackageVersion.setPackageBits(bits);
         newPackageVersion = this.persistOrMergePackageVersionSafely(newPackageVersion);
         existingPackage.addVersion(newPackageVersion);
         return newPackageVersion;
      }
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public PackageVersion persistPackageVersion(PackageVersion pv) {
      if(pv.getGeneralPackage().getId() &gt; 0) {
         pv.setGeneralPackage((Package)this.entityManager.find(Package.class, Integer.valueOf(pv.getGeneralPackage().getId())));
      }

      if(pv.getArchitecture().getId() &gt; 0) {
         pv.setArchitecture((Architecture)this.entityManager.find(Architecture.class, Integer.valueOf(pv.getArchitecture().getId())));
      }

      if(pv.getExtraProperties() != null &amp;&amp; pv.getExtraProperties().getId() &gt; 0) {
         pv.setExtraProperties((Configuration)this.entityManager.find(Configuration.class, Integer.valueOf(pv.getExtraProperties().getId())));
      }

      this.entityManager.persist(pv);
      return pv;
   }

   public PackageVersion persistOrMergePackageVersionSafely(PackageVersion pv) {
      PackageVersion persisted = null;
      RuntimeException error = null;

      try {
         if(pv.getId() == 0) {
            persisted = this.contentManager.persistPackageVersion(pv);
         }
      } catch (RuntimeException var6) {
         error = var6;
      }

      if(persisted == null) {
         Query q = this.entityManager.createNamedQuery(&quot;PackageVersion.findByPackageDetailsKey&quot;);
         q.setParameter(&quot;packageName&quot;, pv.getGeneralPackage().getName());
         q.setParameter(&quot;packageTypeName&quot;, pv.getGeneralPackage().getPackageType().getName());
         q.setParameter(&quot;architectureName&quot;, pv.getArchitecture().getName());
         q.setParameter(&quot;version&quot;, pv.getVersion());
         q.setParameter(&quot;resourceTypeId&quot;, Integer.valueOf(pv.getGeneralPackage().getPackageType().getResourceType().getId()));
         List found = q.getResultList();
         if(error != null &amp;&amp; found.size() == 0) {
            throw error;
         }

         if(found.size() != 1) {
            throw new RuntimeException(&quot;Expecting 1 package version matching [&quot; + pv + &quot;] but got: &quot; + found);
         }

         pv.setId(((PackageVersion)found.get(0)).getId());
         persisted = (PackageVersion)this.entityManager.merge(pv);
         if(error != null) {
            this.log.warn(&quot;There was probably a very big and ugly EJB/hibernate error just above this log message - you can normally ignore that. We detected that a package version was already created when we tried to do it also - we will ignore this and just use the new package version that was created in the other thread&quot;);
         }
      } else {
         persisted = (PackageVersion)this.entityManager.find(PackageVersion.class, Integer.valueOf(persisted.getId()));
         persisted.getGeneralPackage().getId();
         persisted.getArchitecture().getId();
         if(persisted.getExtraProperties() != null) {
            persisted.getExtraProperties().getId();
         }
      }

      return persisted;
   }

   @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
   public Package persistPackage(Package pkg) {
      pkg.setPackageType((PackageType)this.entityManager.find(PackageType.class, Integer.valueOf(pkg.getPackageType().getId())));
      this.entityManager.persist(pkg);
      return pkg;
   }

   public Package persistOrMergePackageSafely(Package pkg) {
      Package persisted = null;
      RuntimeException error = null;

      try {
         if(pkg.getId() == 0) {
            persisted = this.contentManager.persistPackage(pkg);
         }
      } catch (RuntimeException var6) {
         error = var6;
      }

      if(persisted == null) {
         Query q = this.entityManager.createNamedQuery(&quot;Package.findByNameAndPkgTypeId&quot;);
         q.setParameter(&quot;name&quot;, pkg.getName());
         q.setParameter(&quot;packageTypeId&quot;, Integer.valueOf(pkg.getPackageType().getId()));
         List found = q.getResultList();
         if(error != null &amp;&amp; found.size() == 0) {
            throw error;
         }

         if(found.size() != 1) {
            throw new RuntimeException(&quot;Expecting 1 package matching [&quot; + pkg + &quot;] but got: &quot; + found);
         }

         pkg.setId(((Package)found.get(0)).getId());
         persisted = (Package)this.entityManager.merge(pkg);
         if(error != null) {
            this.log.warn(&quot;There was probably a very big and ugly EJB/hibernate error just above this log message - you can normally ignore that. We detected that a package was already created when we tried to do it also - we will ignore this and just use the new package that was created in the other thread&quot;);
         }
      } else {
         persisted = (Package)this.entityManager.find(Package.class, Integer.valueOf(persisted.getId()));
         persisted.getPackageType().getId();
      }

      return persisted;
   }

   private ContentRequestStatus translateRequestResultStatus(ContentResponseResult result) {
      switch(ContentManagerBean.SyntheticClass_1.$SwitchMap$org$rhq$core$domain$content$transfer$ContentResponseResult[result.ordinal()]) {
      case 1:
         return ContentRequestStatus.SUCCESS;
      default:
         return ContentRequestStatus.FAILURE;
      }
   }

   private List translateInstallationSteps(List transferSteps, InstalledPackageHistory history) {
      ArrayList steps = new ArrayList(transferSteps.size());
      int stepOrder = 0;
      Iterator i$ = transferSteps.iterator();

      while(i$.hasNext()) {
         DeployPackageStep transferStep = (DeployPackageStep)i$.next();
         PackageInstallationStep step = new PackageInstallationStep();
         step.setDescription(transferStep.getDescription());
         step.setKey(transferStep.getStepKey());
         step.setResult(transferStep.getStepResult());
         step.setErrorMessage(transferStep.getStepErrorMessage());
         step.setOrder(stepOrder++);
         step.setInstalledPackageHistory(history);
         steps.add(step);
      }

      return steps;
   }

   public List getInstalledPackageVersions(Subject user, int resourceId) {
      Query query = this.entityManager.createNamedQuery(&quot;InstalledPackage.findPackageListVersions&quot;);
      query.setParameter(&quot;resourceId&quot;, Integer.valueOf(resourceId));
      List packages = query.getResultList();
      return packages;
   }

   public PageList findInstalledPackagesByCriteria(Subject subject, InstalledPackageCriteria criteria) {
      CriteriaQueryGenerator generator = new CriteriaQueryGenerator(criteria);
      if(!this.authorizationManager.isInventoryManager(subject)) {
         generator.setAuthorizationResourceFragment(AuthorizationTokenType.RESOURCE, &quot;resource&quot;, subject.getId());
      }

      Query query = generator.getQuery(this.entityManager);
      Query countQuery = generator.getCountQuery(this.entityManager);
      long count = ((Long)countQuery.getSingleResult()).longValue();
      List results = query.getResultList();
      return new PageList(results, (int)count, criteria.getPageControl());
   }

   public PageList findPackageVersionsByCriteria(Subject subject, PackageVersionCriteria criteria) {
      Integer resourceId = criteria.getFilterResourceId();
      if(!this.authorizationManager.isInventoryManager(subject)) {
         if(null == resourceId || criteria.isInventoryManagerRequired()) {
            throw new PermissionException(&quot;Subject [&quot; + subject.getName() + &quot;] requires InventoryManager permission for requested query criteria.&quot;);
         }

         if(!this.authorizationManager.canViewResource(subject, resourceId.intValue())) {
            throw new PermissionException(&quot;Subject [&quot; + subject.getName() + &quot;] does not have permission to view the specified resource.&quot;);
         }
      }

      CriteriaQueryGenerator generator = new CriteriaQueryGenerator(criteria);
      Query query = generator.getQuery(this.entityManager);
      Query countQuery = generator.getCountQuery(this.entityManager);
      long count = ((Long)countQuery.getSingleResult()).longValue();
      List results = query.getResultList();
      return new PageList(results, (int)count, criteria.getPageControl());
   }

   public InstalledPackage getBackingPackageForResource(Subject subject, int resourceId) {
      InstalledPackage result = null;
      InstalledPackageCriteria criteria = new InstalledPackageCriteria();
      criteria.addFilterResourceId(Integer.valueOf(resourceId));
      PageList ips = this.findInstalledPackagesByCriteria(subject, criteria);
      if(null != ips &amp;&amp; 1 == ips.size()) {
         result = (InstalledPackage)ips.get(0);
      }

      return result;
   }

   // $FF: synthetic class
   static class SyntheticClass_1 {
      // $FF: synthetic field
      static final int[] $SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus;
      // $FF: synthetic field
      static final int[] $SwitchMap$org$rhq$core$domain$content$transfer$ContentResponseResult = new int[ContentResponseResult.values().length];

      static {
         try {
            $SwitchMap$org$rhq$core$domain$content$transfer$ContentResponseResult[ContentResponseResult.SUCCESS.ordinal()] = 1;
         } catch (NoSuchFieldError var4) {
            ;
         }

         $SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus = new int[InstalledPackageHistoryStatus.values().length];

         try {
            $SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus[InstalledPackageHistoryStatus.BEING_DELETED.ordinal()] = 1;
         } catch (NoSuchFieldError var3) {
            ;
         }

         try {
            $SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus[InstalledPackageHistoryStatus.BEING_INSTALLED.ordinal()] = 2;
         } catch (NoSuchFieldError var2) {
            ;
         }

         try {
            $SwitchMap$org$rhq$core$domain$content$InstalledPackageHistoryStatus[InstalledPackageHistoryStatus.BEING_RETRIEVED.ordinal()] = 3;
         } catch (NoSuchFieldError var1) {
            ;
         }

      }
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Sep 8, 2017 11:31:17 AM</div>
    <script src="resources/js/jquery-1.10.1.min.js"></script>
    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });




            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4062208;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>

</body>
</html>
